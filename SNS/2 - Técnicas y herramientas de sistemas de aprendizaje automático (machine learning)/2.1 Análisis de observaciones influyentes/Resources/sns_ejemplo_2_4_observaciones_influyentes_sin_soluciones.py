# -*- coding: utf-8 -*-
"""SNS Ejemplo_2_4_Observaciones_influyentes_Sin soluciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ePJQs9d-IkHQsX10ceuapA8dS6oDFSUj

*Adri√°n Yared Armas de la Nuez*

# Datos de la actividad
"""

# LIBRER√çAS EMPLEADAS EN EL EJEMPLO
# Tratamiento de datos
# ==============================================================================
import numpy as np
import pandas as pd

# Generaci√≥n de datos
# ==============================================================================
# Generamos (100 elementos) ingresos uniformemente distribuidos en [15000,25000]
datos = 15000+np.random.rand(100)*10000
datos_ord = datos
datos_ord.sort()
datos

"""# 1. A partir del c√≥digo de ejemplo utilizado en el notebook Ejemplo_2_4_Observaciones_influyentes_Sin soluciones.ipynb Url: https://colab.research.google.com/drive/11JM5daNQUCB_VSAOHmpFjHmFuZDsB3-i?usp=sharing

##  *Calcular* la media y la mediana antes de realizar la modificaci√≥n de incluir unos ingresos de 500.000‚Ç¨
"""

# Calcular la media y mediana antes de incluir el ingreso de 500,000‚Ç¨
media_inicial = np.mean(datos)
mediana_inicial = np.median(datos)

print(f"Media inicial: {media_inicial}")
print(f"Mediana inicial: {mediana_inicial}")

"""## Aplicar el m√©todo de Probabilidad global, para detectar los outliers utilizado en el ejemplo 2_3_Outliers (Url: https://colab.research.google.com/drive/1C6uBUxui_Qq9ee-51ycVYcqigrSHSZNY?usp=sharing)"""

import scipy.stats as st

# Probabilidad global
p_g = 0.95
alfa_g = (1 - p_g) / 2

# Probabilidad ajustada para un dato
alfa = 1 - (1 - alfa_g) ** (1 / len(datos))
Z_alfa = st.norm.ppf(1 - alfa / 2)

# Intervalo de aceptaci√≥n
xL = round(np.mean(datos) - Z_alfa * np.std(datos), 4)
xU = round(np.mean(datos) + Z_alfa * np.std(datos), 4)

# Identificaci√≥n de outliers
outliers = [i for i, val in enumerate(datos) if val < xL or val > xU]

print(f"Alfa: {round(alfa, 5)}")
print(f"Z_alfa: {round(Z_alfa, 5)}")
print(f"Banda: [{xL}, {xU}]")
print(f"Outliers detectados: {outliers}")

"""## Repetir el mismo procedimiento de detectar los outliers para la mediana: ¬øQu√© ocurre?"""

# Detectar outliers usando el rango intercuartil (IQR) basado en la mediana
q1 = np.percentile(datos, 25)
q3 = np.percentile(datos, 75)
iqr = q3 - q1

# L√≠mites inferior y superior usando el rango intercuartil
limite_inferior = q1 - 1.5 * iqr
limite_superior = q3 + 1.5 * iqr

outliers_mediana = [i for i, val in enumerate(datos) if val < limite_inferior or val > limite_superior]

print(f"Cuartil 1: {q1}")
print(f"Cuartil 3: {q3}")
print(f"IQR: {iqr}")
print(f"L√≠mite inferior: {limite_inferior}")
print(f"L√≠mite superior: {limite_superior}")
print(f"Outliers detectados basados en la mediana: {outliers_mediana}")

"""## Integraci√≥n del m√©todo Jackknife para la detecci√≥n de influencia"""

# M√©todo Jackknife para evaluar la influencia en la media y mediana
phi_media = np.zeros(len(datos))
phi_mediana = np.zeros(len(datos))

for i in range(len(datos)):
    datos_sin_i = np.delete(datos, i)
    media_sin_i = np.mean(datos_sin_i)
    mediana_sin_i = np.median(datos_sin_i)

    phi_media[i] = abs(media_inicial - media_sin_i)
    phi_mediana[i] = abs(mediana_inicial - mediana_sin_i)

# Identificar los datos m√°s influyentes
influyente_media = np.argmax(phi_media)
influyente_mediana = np.argmax(phi_mediana)

print(f"Dato m√°s influyente en la media: √çndice {influyente_media}, Valor {datos[influyente_media]}")
print(f"Dato m√°s influyente en la mediana: √çndice {influyente_mediana}, Valor {datos[influyente_mediana]}")

"""# 2. A partir del c√≥digo de ejemplo utilizado en el notebook
Ejemplo_2_5_Escalamiento_de_datos_Sin soluciones.ipynb
Url: https://colab.research.google.com/drive/11vLMbjw5XmF7dJks0b04gfMdCnClE0Kw?usp=sharing

## a) ¬øCu√°nto vale la media, mediana, la desviaci√≥n est√°ndar muestral, la varianza muestral y el rango de la variable X?
"""

x = np.array ([1,2,3,4,5,6,7,8,9,10])
media = np.mean(x)
mediana = np.median(x)
desviacion_estandar = np.std(x)
varianza = np.var(x)
rango = np.ptp(x)

print(f"Media: {media}")
print(f"Mediana: {mediana}")
print(f"Desviaci√≥n est√°ndar: {desviacion_estandar}")
print(f"Varianza: {varianza}")
print(f"Rango: {rango}")

"""**Explicaci√≥n:**
<br>
El c√≥digo calcula estad√≠sticas descriptivas de un arreglo x que contiene los n√∫meros del 1 al 10. La media y la mediana son ambas 5.5, reflejando la simetr√≠a de los datos. La desviaci√≥n est√°ndar es aproximadamente 2.87, indicando la dispersi√≥n promedio de los valores respecto a la media, mientras que la varianza (8.25) mide la dispersi√≥n al cuadrado. Finalmente, el rango (9) representa la diferencia entre el valor m√°ximo (10) y el m√≠nimo (1), mostrando la amplitud total de los datos.

## b) Utilizar la funci√≥n describe() de Panda, para obtener la media, desviaci√≥n est√°ndar, etc‚Ä¶
"""

print(pd.DataFrame(x).describe())

"""**Explicaci√≥n:**
<br>
El c√≥digo pd.DataFrame(x).describe() genera un resumen estad√≠stico de la variable x, que contiene 10 valores del 1 al 10. Muestra que hay 10 datos (count), con una media y mediana de 5.5 (mean y 50%), una desviaci√≥n est√°ndar de 3.02765 (std), un rango que va desde el m√≠nimo 1.0 (min) al m√°ximo 10.0 (max), y percentiles clave como el 25% (3.25) y 75% (7.75). Esto resume de forma compacta la distribuci√≥n y dispersi√≥n de los datos.

## c) ¬øPor qu√© el resultado de calcular la desviaci√≥n est√°ndar con Numpy es diferente a la calculada por describe de Panda? ¬øQu√© ajuste ser√≠a necesario realizar para que los resultados fuesen similares/iguales?
"""

import numpy as np
import pandas as pd

# Datos de ejemplo
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Numpy: desviaci√≥n est√°ndar poblacional
std_numpy_pop = np.std(data)  # Por defecto ddof=0
print("Numpy (poblacional):", std_numpy_pop)

# Numpy: desviaci√≥n est√°ndar muestral
std_numpy_sample = np.std(data, ddof=1)  # Igual que describe() de Pandas
print("Numpy (muestral):", std_numpy_sample)

# Pandas: desviaci√≥n est√°ndar (muestral)
std_pandas = pd.Series(data).std()  # Por defecto ddof=1
print("Pandas (muestral):", std_pandas)

# Pandas: desviaci√≥n est√°ndar poblacional
std_pandas_pop = pd.Series(data).std(ddof=0)
print("Pandas (poblacional):", std_pandas_pop)

"""**Explicaci√≥n:**
<br>
La diferencia surge porque Numpy, por defecto, calcula la desviaci√≥n est√°ndar poblacional (dividiendo por ùëÅ), mientras que Pandas' describe usa la desviaci√≥n est√°ndar muestral (dividiendo por ùëÅ‚àí1, que es el sesgo corregido o "Bessel's correction"). Para hacer que los resultados sean iguales, puedes ajustar Numpy para que use el mismo m√©todo muestral estableciendo ddof=1 en la funci√≥n np.std. As√≠, ambos c√°lculos usar√°n la correcci√≥n ùëÅ‚àí1.

## d) Estandarizar la variable (escalamiento) mediante rangos y a continuaci√≥n calcular la media y la mediana de la variable escalada
"""

import numpy as np
import pandas as pd

# Datos
X = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Escalamiento mediante rangos: (X - min(X)) / (max(X) - min(X))
X_scaled = (X - X.min()) / (X.max() - X.min())

# C√°lculo de la media y mediana de la variable escalada
mean_scaled = np.mean(X_scaled)
median_scaled = np.median(X_scaled)

print(f"Media escalada: {mean_scaled}")
print(f"Mediana escalada: {median_scaled}")

"""**Explicaci√≥n:**
<br>
El escalamiento mediante rangos transforma los valores de la variable X al intervalo [0, 1], manteniendo las proporciones relativas. En este caso, la distribuci√≥n original de X es uniforme y sim√©trica, por lo que su valor central (mediana) y promedio (media) tambi√©n est√°n en el punto medio del rango escalado, es decir, 0.5. Este resultado refleja que la transformaci√≥n no altera la simetr√≠a de la distribuci√≥n. Adem√°s, la media y mediana coinciden porque la distribuci√≥n permanece uniforme tras el escalado.

## e) Repetir el apartado anterior con el escalamiento Z - score
"""

# Escalamiento Z-score: (X - mean(X)) / std(X)
X_zscore = (X - X.mean()) / X.std()

# C√°lculo de la media y mediana de la variable escalada
mean_zscore = np.mean(X_zscore)
median_zscore = np.median(X_zscore)

print(f"Media escalada z-score: {mean_zscore}")
print(f"Mediana escalada z-score: {median_zscore}")

"""El escalamiento Z-score transforma los datos para que tengan una media de 0 y una desviaci√≥n est√°ndar de 1. En este caso, la media calculada es aproximadamente 0 (con un error num√©rico insignificante, ~10^-17), lo cual confirma el centrado. La mediana de 0 indica que el valor central de los datos escalados tambi√©n coincide con el centro de la distribuci√≥n normalizada. Este m√©todo es √∫til para comparar datos en diferentes escalas, ya que elimina efectos de magnitud o unidad original.

**Explicaci√≥n:**
<br>
El escalamiento Z-score transforma los datos para que tengan una media de 0 y una desviaci√≥n est√°ndar de 1. En este caso, la media calculada es aproximadamente 0 (con un error num√©rico insignificante, ~10^‚àí17, lo cual confirma el centrado. La mediana de 0 indica que el valor central de los datos escalados tambi√©n coincide con el centro de la distribuci√≥n normalizada. Este m√©todo es √∫til para comparar datos en diferentes escalas, ya que elimina efectos de magnitud o unidad original.
"""